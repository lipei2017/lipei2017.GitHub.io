{"componentChunkName":"component---src-templates-blog-post-js","path":"/js/","result":{"data":{"markdownRemark":{"html":"<h3>Array.prototype.slice()</h3>\n<p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括 end）。原始数组不会被改变。</p>\n<h3>Array.from()</h3>\n<p>方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>\n<pre><code class=\"language-js\">console.log(Array.from('foo'));\n// expected output: Array [\"f\", \"o\", \"o\"]\n\nconsole.log(Array.from([1, 2, 3], (x) => x + x));\n// expected output: Array [2, 4, 6]\n</code></pre>\n<blockquote>\n<p>Array.from(arrayLike[, mapFn[, thisArg]])</p>\n</blockquote>\n<h3>Array.prototype.reduce()</h3>\n<p>方法对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。</p>\n<pre><code class=\"language-js\">const array1 = [1, 2, 3, 4];\nconst reducer = (accumulator, currentValue) => accumulator + currentValue;\n\n// 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer));\n// expected output: 10\n\n// 5 + 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer, 5));\n// expected output: 15\n</code></pre>\n<blockquote>\n<p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>\n</blockquote>\n<h3>Function.prototype.bind()</h3>\n<p>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用</p>\n<pre><code class=\"language-js\">const module = {\n  x: 42,\n  getX() {\n    return this.x;\n  },\n};\nconst boundGetX = module.getX.bind(module);\nconsole.log(boundGetX());\n</code></pre>\n<h3>Function.prototype.call()</h3>\n<p>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。</p>\n<pre><code class=\"language-js\">function Product(name, price) {\n  this.name = name;\n  this.price = price;\n}\nfunction Food(name, price) {\n  Product.call(this, name, price);\n  this.category = 'food';\n}\nconsole.log(new Food('cheese', 5).name);\n// expected output: \"cheese\"\n</code></pre>\n<h2>并不能说对象有原型，而只能说对象的构造求有原型</h2>","frontmatter":{"title":"js.note"}}},"pageContext":{"slug":"/js/"}},"staticQueryHashes":["3159585216"]}