{"componentChunkName":"component---src-templates-blog-post-js","path":"/module/","result":{"data":{"markdownRemark":{"html":"<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>\n<pre><code class=\"language-js\">// CommonJS模块\nlet { stat, exists, readfile } = require('fs');\n\n// 等同于\nlet _fs = require('fs');\nlet stat = _fs.stat;\nlet exists = _fs.exists;\nlet readfile = _fs.readfile;\n</code></pre>\n<p>上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>\n<p><strong>ES6 模块不是对象</strong>，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。</p>\n<h2>UMD</h2>\n<blockquote>\n<p>既可以通过 <code>&#x3C;script></code> 标签引入，又可以通过 import 导入的库，称为 UMD 库</p>\n</blockquote>\n<h2>CommonJs</h2>\n<blockquote>\n<p>用于服务器</p>\n</blockquote>\n<h2>AMD</h2>\n<blockquote>\n<p>用于浏览器</p>\n</blockquote>\n<h2>ES6 模块与 CommonJS 模块的差异</h2>\n<ul>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>\n<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>\n<li>CommonJS 模块的 require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。</li>\n</ul>","frontmatter":{"title":"module"}}},"pageContext":{"slug":"/module/"}},"staticQueryHashes":["3159585216"]}